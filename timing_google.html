<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Interval Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .modal {
            display: none;
            /* Hidden by default */
            position: fixed;
            /* Stay in place */
            z-index: 1000;
            /* Sit on top */
            left: 0;
            top: 0;
            width: 100%;
            /* Full width */
            height: 100%;
            /* Full height */
            overflow: auto;
            /* Enable scroll if needed */
            background-color: rgba(0, 0, 0, 0.5);
            /* Black w/ opacity */
            backdrop-filter: blur(5px);
            align-items: center;
            /* For vertical centering of modal-content */
            justify-content: center;
            /* For horizontal centering of modal-content */
        }

        .modal-content {
            background-color: #fefefe;
            /* margin: 10% auto; */
            /* Replaced by flexbox centering */
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            /* Could be more or less, depending on screen size */
            max-width: 500px;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .inactive-row {
            background-color: #e5e7eb;
            /* Tailwind gray-200 */
            opacity: 0.7;
        }

        .inactive-row input,
        .inactive-row select,
        .inactive-row textarea {
            background-color: #f3f4f6;
            /* Tailwind gray-100 */
            cursor: not-allowed;
        }

        .time-exceeded {
            color: #ef4444;
            /* Tailwind red-500 */
            font-weight: bold;
        }

        #tasksContainerWrapper::-webkit-scrollbar {
            width: 8px;
        }

        #tasksContainerWrapper::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        #tasksContainerWrapper::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }

        #tasksContainerWrapper::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .table-header th {
            position: sticky;
            top: 0;
            background-color: white;
            z-index: 10;
        }

        .dragging {
            opacity: 0.5;
            background: #c7d2fe;
            /* Tailwind indigo-200 */
        }

        .drag-over-indicator {
            border-top: 2px dashed #3b82f6;
            /* Tailwind blue-500 */
        }

        .drag-handle {
            cursor: grab;
            padding-right: 8px;
            /* Space for the handle */
            user-select: none;
            /* Prevent text selection when dragging */
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        input[readonly]:not(.inactive-row input),
        textarea[readonly]:not(.inactive-row textarea) {
            background-color: #e9ecef;
            /* Light gray for readonly inputs on active rows */
            cursor: default;
        }
    </style>
</head>

<body class="bg-gray-100 text-gray-800 p-4 md:p-8">
    <div class="container mx-auto max-w-6xl bg-white p-6 rounded-lg shadow-xl">
        <header class="mb-6 border-b pb-4">
            <h1 class="text-3xl font-bold text-center text-blue-600 mb-4">Time Interval Manager</h1>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4 items-end">
                <div>
                    <label for="programTemplate" class="block text-sm font-medium text-gray-700">Load Program
                        Template:</label>
                    <select id="programTemplate"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                        <option value="custom">Custom Program</option>
                        <option value="sabbathMorning">Sabbath Morning</option>
                        <option value="sabbathAfternoon">Sabbath Afternoon</option>
                    </select>
                </div>
                <div>
                    <label for="globalStartTime" class="block text-sm font-medium text-gray-700">Global Start
                        Time:</label>
                    <input type="time" id="globalStartTime"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                </div>
                <div>
                    <label for="globalEndTime" class="block text-sm font-medium text-gray-700">Global End Time:</label>
                    <input type="time" id="globalEndTime"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                </div>
            </div>

            <div id="timeSummary" class="text-sm bg-blue-50 p-3 rounded-md">
                <p>Total Session Length: <span id="totalSessionLength" class="font-semibold">0 min</span></p>
                <p>Total Active Task Time: <span id="totalActiveTime" class="font-semibold">0 min</span></p>
                <p>Time Remaining in Session: <span id="timeRemaining" class="font-semibold">0 min</span></p>
                <p id="timeLimitWarning" class="font-semibold" style="display:none;">Time limit exceeded!</p>
            </div>

            <div id="activeTimerDisplay" class="mt-4 p-4 bg-yellow-100 border border-yellow-400 rounded-md shadow"
                style="display:none;">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-lg font-semibold text-yellow-800">Ongoing Task: <span id="activeTimerProgramName"
                            class="text-blue-600"></span></h3>
                    <button id="activeTimerStopBtn" Bihari
                        class="bg-red-500 hover:bg-red-600 text-white font-semibold py-1 px-3 rounded-md shadow-md text-sm">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block mr-1" viewBox="0 0 20 20"
                            fill="currentColor">
                            <path fill-rule="evenodd"
                                d="M10 18a8 8 0 100-16 8 8 0 000 16zm0-2a6 6 0 100-12 6 6 0 000 12zm-1-5a1 1 0 011-1h2a1 1 0 110 2h-2a1 1 0 01-1-1z"
                                clip-rule="evenodd" />
                        </svg>
                        Stop Timer</button>
                </div>
                <div class="grid grid-cols-3 gap-2 text-sm">
                    <p><span class="font-medium text-gray-700">Scheduled:</span> <span id="activeTimerScheduledDuration"
                            class="font-mono text-gray-600"></span></p>
                    <p><span class="font-medium text-green-700">Elapsed:</span> <span id="activeTimerElapsedTime"
                            class="font-mono font-bold text-green-600">00:00:00</span></p>
                    <p><span class="font-medium text-red-700">Remaining:</span> <span id="activeTimerCountdown"
                            class="font-mono font-bold text-red-600">00:00:00</span></p>
                </div>
            </div>
        </header>

        <div class="mb-6 flex flex-wrap gap-2">
            <button id="addRowBtn"
                class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md shadow-md transition duration-150 ease-in-out">
                Add Program Task
            </button>
            <button id="exportJsonBtn"
                class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-md shadow-md transition duration-150 ease-in-out">
                Export JSON
            </button>
            <input type="file" id="importJsonInput" accept=".json" style="display:none;">
            <button id="importJsonBtn"
                class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 px-4 rounded-md shadow-md transition duration-150 ease-in-out">
                Import JSON
            </button>
            <button id="exportExcelBtn"
                class="bg-purple-500 hover:bg-purple-600 text-white font-semibold py-2 px-4 rounded-md shadow-md transition duration-150 ease-in-out">
                Export Excel
            </button>
        </div>

        <div id="tasksContainerWrapper" class="overflow-x-auto max-h-[60vh] overflow-y-auto rounded-md border">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr class="table-header">
                        <th class="px-1 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-10">
                        </th>
                        <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Status</th>
                        <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Program Name</th>
                        <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Start
                            Time</th>
                        <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">End
                            Time</th>
                        <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Duration (min)</th>
                        <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Remarks</th>
                        <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Actions</th>
                    </tr>
                </thead>
                <tbody id="tasksContainer" class="bg-white divide-y divide-gray-200">
                </tbody>
            </table>
        </div>
        <p class="mt-4 text-xs text-gray-500">Tip: Drag rows by the handle (☰) to reorder. Change Start Time of the
            first active task, or Duration, to shift subsequent tasks. Modifying End Time will adjust Duration. </p>
    </div>

    <div id="warningModal" class="modal">
        <div class="modal-content text-center">
            <h2 class="text-2xl font-semibold mb-2 text-yellow-500">Warning!</h2>
            <p class="mb-4">The scheduled time for "<span id="warningProgramName" class="font-semibold"></span>" is up!
            </p>
            <p class="mb-4 text-sm text-gray-600">The timer will continue counting up until you manually stop it.</p>
            <button id="closeWarningModalBtn"
                class="bg-yellow-400 hover:bg-yellow-500 text-gray-800 font-bold py-2 px-4 rounded-md w-full shadow-md transition duration-150 ease-in-out">OK,
                Continue Timer</button>
        </div>
    </div>

    <script>
        // --- Global State ---
        let tasks = [];
        let globalStartTime = "09:00";
        let globalEndTime = "17:00";
        let nextTaskId = 1;
        let activeTimerInterval = null;
        let currentTimerTaskIndex = -1; // Index in the tasks array
        let elapsedSeconds = 0;
        let draggedItem = null; // For drag and drop

        // --- DOM Elements ---
        const programTemplateSelect = document.getElementById('programTemplate');
        const globalStartTimeInput = document.getElementById('globalStartTime');
        const globalEndTimeInput = document.getElementById('globalEndTime');
        const addRowBtn = document.getElementById('addRowBtn');
        const tasksContainer = document.getElementById('tasksContainer');
        const exportJsonBtn = document.getElementById('exportJsonBtn');
        const importJsonInput = document.getElementById('importJsonInput');
        const importJsonBtn = document.getElementById('importJsonBtn');
        const exportExcelBtn = document.getElementById('exportExcelBtn');

        const totalSessionLengthEl = document.getElementById('totalSessionLength');
        const totalActiveTimeEl = document.getElementById('totalActiveTime');
        const timeRemainingEl = document.getElementById('timeRemaining');
        const timeLimitWarningEl = document.getElementById('timeLimitWarning');

        // New Timer Display Elements
        const activeTimerDisplay = document.getElementById('activeTimerDisplay');
        const activeTimerProgramNameEl = document.getElementById('activeTimerProgramName');
        const activeTimerScheduledDurationEl = document.getElementById('activeTimerScheduledDuration');
        const activeTimerElapsedTimeEl = document.getElementById('activeTimerElapsedTime');
        const activeTimerCountdownEl = document.getElementById('activeTimerCountdown');
        const activeTimerStopBtn = document.getElementById('activeTimerStopBtn');

        const warningModal = document.getElementById('warningModal');
        const warningProgramNameEl = document.getElementById('warningProgramName');
        const closeWarningModalBtn = document.getElementById('closeWarningModalBtn');

        // --- Program Templates Data ---
        const programTemplates = {
            custom: { globalStartTime: "09:00", globalEndTime: "17:00", tasks: [] },
            sabbathMorning: { /* ... existing template data ... */ },
            sabbathAfternoon: { /* ... existing template data ... */ }
        };
        // (Make sure to copy your full programTemplates object here if it's not minimal)
        programTemplates.sabbathMorning = {
            globalStartTime: "08:30",
            globalEndTime: "11:35",
            tasks: [
                { programName: "SESA", duration: 30, remarks: "Sekoly Sabata Ankizy" },
                { programName: "SESA", duration: 20, remarks: "Sekoly Sabata Lehibe - Fizarana Kilasy" },
                { programName: "Lesona", duration: 45, remarks: "Famakiana Lesona Iraisana" },
                { programName: "10 mn SESA", duration: 10, remarks: "Asa Misionera sy Hafatra manokana" },
                { programName: "Pause", duration: 5, remarks: "Fiatoana kely" },
                { programName: "Filazana", duration: 10, remarks: "Filazana sy Fandraisana Mpamangy" },
                { programName: "Culte", duration: 65, remarks: "Fotoam-pivavahana" }
            ]
        };
        programTemplates.sabbathAfternoon = {
            globalStartTime: "14:30",
            globalEndTime: "17:00",
            tasks: [
                { programName: "Hira", duration: 1, remarks: "" }, { programName: "Vavaka", duration: 1, remarks: "" },
                { programName: "Fiarahabana", duration: 1, remarks: "" }, { programName: "Hira", duration: 1, remarks: "" },
                { programName: "Fandalinana", duration: 20, remarks: "" }, { programName: "Hira", duration: 1, remarks: "" },
                { programName: "Tanora", duration: 45, remarks: "JA" },
                { programName: "Fotoana Voalamina", duration: 7, remarks: "Ankizy / Dorcas / Hommes" },
                { programName: "Hira", duration: 1, remarks: "" }, { programName: "Fanabeazana", duration: 5, remarks: "Sante / Foyer" },
                { programName: "Hira", duration: 1, remarks: "" }, { programName: "Hira", duration: 1, remarks: "" },
                { programName: "Sampana 3", duration: 15, remarks: "AFAM / Diakona / Sekretera" },
                { programName: "Hira", duration: 1, remarks: "" }, { programName: "Manuelle", duration: 15, remarks: "Asa Tanana / Zavamaneno" },
                { programName: "Hira", duration: 1, remarks: "" }, { programName: "Fampidirana Lesona", duration: 10, remarks: "Lesona Herinandro Manaraka" },
                { programName: "Filazana Raharaha", duration: 3, remarks: "" }, { programName: "Hira", duration: 1, remarks: "" },
                { programName: "Vatsy", duration: 15, remarks: "Vatsy an-dalana ara-panahy" },
                { programName: "Hira", duration: 1, remarks: "" }, { programName: "Vavaka", duration: 1, remarks: "Famaranana" }
            ]
        };


        // --- Utility Functions ---
        function timeToMinutes(timeStr) {
            if (!timeStr || !timeStr.includes(':')) return 0;
            const [hours, minutes] = timeStr.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function minutesToTime(totalMinutes) {
            if (isNaN(totalMinutes) || totalMinutes < 0) totalMinutes = 0;
            const hours = Math.floor(totalMinutes / 60);
            const minutes = Math.round(totalMinutes % 60);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        function formatDuration(minutes) {
            if (isNaN(minutes) || minutes < 0) return "0m";
            const h = Math.floor(minutes / 60);
            const m = Math.round(minutes % 60);
            let parts = [];
            if (h > 0) parts.push(`${h}h`);
            if (m > 0 || h === 0) parts.push(`${m}m`);
            return parts.join(' ') || "0m";
        }

        function formatSecondsToHHMMSS(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function getCurrentDateString() {
            const date = new Date();
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // --- Core Task Functions ---
        function renderTasks() {
            tasksContainer.innerHTML = '';
            if (tasks.length === 0) {
                tasksContainer.innerHTML = `<tr><td colspan="8" class="text-center py-4 text-gray-500">No program tasks yet. Click "Add Program Task" or load a template.</td></tr>`;
            }
            const isTaskTiming = activeTimerInterval !== null;

            tasks.forEach((task, index) => {
                const row = document.createElement('tr');
                row.dataset.taskId = task.id;
                row.draggable = true;
                row.className = `transition-colors duration-200 ${task.isActive ? '' : 'inactive-row'}`;

                const durationMinutes = task.duration > 0 ? task.duration : calculateDuration(task.startTime, task.endTime);
                const isCurrentTimingTask = isTaskTiming && tasks[currentTimerTaskIndex] && tasks[currentTimerTaskIndex].id === task.id;

                row.innerHTML = `
                    <td class="px-1 py-2 whitespace-nowrap drag-handle text-gray-400 hover:text-blue-500" title="Drag to reorder">☰</td>
                    <td class="px-3 py-2 whitespace-nowrap">
                        <button class="toggleStatusBtn p-1 rounded ${task.isActive ? 'bg-green-100 text-green-700 hover:bg-green-200' : 'bg-gray-300 text-gray-700 hover:bg-gray-400'}" 
                                title="${task.isActive ? 'Deactivate' : 'Activate'} Task" ${isCurrentTimingTask ? 'disabled' : ''}>
                            ${task.isActive ?
                        '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" /></svg>' :
                        '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 9a1 1 0 000 2h6a1 1 0 100-2H7z" clip-rule="evenodd" /></svg>'}
                        </button>
                    </td>
                    <td class="px-3 py-2"><input type="text" value="${task.programName}" class="programNameInput p-1 border rounded-md w-full text-sm" ${(!task.isActive || isCurrentTimingTask) ? 'readonly' : ''}></td>
                    <td class="px-3 py-2"><input type="time" value="${task.startTime}" class="startTimeInput p-1 border rounded-md w-full text-sm" ${(!task.isActive || isCurrentTimingTask) ? 'readonly' : ''}></td>
                    <td class="px-3 py-2"><input type="time" value="${task.endTime}" class="endTimeInput p-1 border rounded-md w-full text-sm" ${(!task.isActive || isCurrentTimingTask) ? 'readonly' : ''}></td>
                    <td class="px-3 py-2"><input type="number" value="${durationMinutes}" min="0" class="durationInput p-1 border rounded-md w-20 text-sm" ${(!task.isActive || isCurrentTimingTask) ? 'readonly' : ''}> min</td>
                    <td class="px-3 py-2"><textarea class="remarksInput p-1 border rounded-md w-full text-sm" rows="2" ${(!task.isActive || isCurrentTimingTask) ? 'readonly' : ''}>${task.remarks}</textarea></td>
                    <td class="px-3 py-2 whitespace-nowrap">
                        <button class="startTimerBtn bg-blue-500 hover:bg-blue-600 text-white px-2 py-1 rounded-md text-xs mr-1" ${(!task.isActive || isCurrentTimingTask || isTaskTiming) ? 'disabled' : ''} title="Start Timer">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg> Start
                        </button>
                        <button class="removeRowBtn bg-red-500 hover:bg-red-600 text-white px-2 py-1 rounded-md text-xs" title="Remove Task" ${isCurrentTimingTask ? 'disabled' : ''}>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg> Remove
                        </button>
                    </td>
                `;
                tasksContainer.appendChild(row);
            });
            updateOverallTimeSummary();
            saveState();
        }

        function addTask() {
            const previousActiveTask = [...tasks].reverse().find(t => t.isActive);
            let newStartTime = globalStartTime;
            if (previousActiveTask) {
                newStartTime = previousActiveTask.endTime;
            } else if (tasks.length > 0 && tasks.some(t => t.isActive)) {
                // Find the earliest start time among active tasks if globalStartTime is not suitable
                // This case is complex; for simplicity, new tasks usually chain from the last active.
                // If no active tasks, newStartTime remains globalStartTime.
            } else if (tasks.length > 0 && !tasks.some(t => t.isActive)) {
                // All tasks are inactive, place it after the last task overall or at globalStartTime
                newStartTime = tasks[tasks.length - 1].endTime;
            }


            const newTask = {
                id: nextTaskId++,
                programName: `Program ${tasks.length + 1}`,
                startTime: newStartTime,
                endTime: minutesToTime(timeToMinutes(newStartTime) + 30),
                duration: 30,
                remarks: '',
                isActive: true,
                timerIntervalId: null, // This property seems unused, can be removed
                elapsedSeconds: 0,     // This property seems unused here, managed globally for timer
                timerStartTimeActual: null,
                timerActualStartTimeValue: null
            };
            tasks.push(newTask);
            recalculateChain();
        }

        function removeTask(taskId) {
            tasks = tasks.filter(task => task.id !== taskId);
            recalculateChain();
        }

        function toggleTaskStatus(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                const taskIndexInArr = tasks.findIndex(t => t.id === taskId);
                task.isActive = !task.isActive;
                if (!task.isActive && currentTimerTaskIndex !== -1 && tasks[currentTimerTaskIndex].id === taskId) {
                    stopChrono(true); // Stop timer if deactivated task is the one being timed
                }
            }
            recalculateChain();
        }

        function updateTaskData(taskId, field, value) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex === -1) return;

            const task = tasks[taskIndex];
            if (!task.isActive && field !== 'isActive') return; // Don't update inactive task details other than its status toggle

            let needsRecalculate = false;
            task.userInputSourceField = field; // Store what field user interacted with for recalc logic

            if (field === 'startTime') {
                task.startTime = value;
                needsRecalculate = true;
            } else if (field === 'endTime') {
                task.endTime = value;
                const newDuration = calculateDuration(task.startTime, task.endTime);
                if (newDuration >= 0) {
                    task.duration = newDuration;
                } else {
                    task.endTime = minutesToTime(timeToMinutes(task.startTime) + task.duration); // Revert if invalid
                }
                needsRecalculate = true;
            } else if (field === 'duration') {
                task.duration = parseInt(value, 10) || 0;
                needsRecalculate = true;
            } else if (field === 'programName') {
                task.programName = value;
                saveState(); // Save on direct text input, no full re-render to preserve focus
                return;
            } else if (field === 'remarks') {
                task.remarks = value;
                saveState(); // Save on direct text input, no full re-render to preserve focus
                return;
            }

            if (needsRecalculate) {
                recalculateChain(taskIndex);
            } else {
                renderTasks(); // Fallback, though should be covered by above
            }
        }


        function calculateDuration(startTime, endTime) {
            const startMinutes = timeToMinutes(startTime);
            const endMinutes = timeToMinutes(endTime);
            const duration = endMinutes - startMinutes;
            return duration >= 0 ? duration : 0;
        }

        function recalculateChain(changedByUserAtIndex = -1) {
            let currentChainStartTimeMinutes = timeToMinutes(globalStartTime);
            let firstActiveTaskProcessed = false;

            for (let i = 0; i < tasks.length; i++) {
                const task = tasks[i];
                if (task.isActive) {
                    if (!firstActiveTaskProcessed) { // This is the first active task in the current iteration
                        if (i === changedByUserAtIndex && task.userInputSourceField === 'startTime') {
                            // User explicitly set the startTime of the first active task. Honor it.
                            currentChainStartTimeMinutes = timeToMinutes(task.startTime);
                        } else {
                            // Set startTime based on global start or previous (non-existent here)
                            task.startTime = minutesToTime(currentChainStartTimeMinutes);
                        }
                        firstActiveTaskProcessed = true;
                    } else {
                        // Subsequent active task. If its start time was changed by user, that should anchor.
                        if (i === changedByUserAtIndex && task.userInputSourceField === 'startTime') {
                            currentChainStartTimeMinutes = timeToMinutes(task.startTime); // Anchor from this point
                        } else {
                            task.startTime = minutesToTime(currentChainStartTimeMinutes);
                        }
                    }
                    task.endTime = minutesToTime(timeToMinutes(task.startTime) + task.duration);
                    currentChainStartTimeMinutes = timeToMinutes(task.endTime);
                }
            }
            renderTasks();
        }


        function updateGlobalTimes() {
            globalStartTime = globalStartTimeInput.value || "00:00";
            globalEndTime = globalEndTimeInput.value || "23:59";
            recalculateChain();
            // updateOverallTimeSummary(); // Called by renderTasks in recalculateChain
        }

        function updateOverallTimeSummary() {
            const globalStartMinutes = timeToMinutes(globalStartTime);
            const globalEndMinutes = timeToMinutes(globalEndTime);

            const totalSessionMinutes = Math.max(0, globalEndMinutes - globalStartMinutes);
            totalSessionLengthEl.textContent = formatDuration(totalSessionMinutes);

            let currentTotalActiveDuration = 0;
            tasks.forEach(task => {
                if (task.isActive) {
                    currentTotalActiveDuration += task.duration;
                }
            });
            totalActiveTimeEl.textContent = formatDuration(currentTotalActiveDuration);

            const remainingMinutes = totalSessionMinutes - currentTotalActiveDuration;
            timeRemainingEl.textContent = formatDuration(remainingMinutes);
            timeRemainingEl.classList.toggle('time-exceeded', remainingMinutes < 0);

            if (currentTotalActiveDuration > totalSessionMinutes) {
                timeLimitWarningEl.textContent = `Time limit exceeded by ${formatDuration(currentTotalActiveDuration - totalSessionMinutes)}!`;
                timeLimitWarningEl.style.display = 'block';
                timeLimitWarningEl.classList.add('time-exceeded');
            } else {
                timeLimitWarningEl.style.display = 'none';
                timeLimitWarningEl.classList.remove('time-exceeded');
            }
            // saveState(); // Called by renderTasks
        }

        function setTaskInputsLocked(taskId, locked) {
            const row = tasksContainer.querySelector(`tr[data-task-id="${taskId}"]`);
            if (row) {
                row.querySelectorAll('input.programNameInput, input.startTimeInput, input.endTimeInput, input.durationInput, textarea.remarksInput').forEach(input => {
                    if (locked) {
                        input.setAttribute('readonly', true);
                        input.style.backgroundColor = '#e9ecef';
                    } else {
                        input.removeAttribute('readonly');
                        input.style.backgroundColor = ''; // Reset to default or inherited
                    }
                });
                row.querySelectorAll('.startTimerBtn, .removeRowBtn, .toggleStatusBtn').forEach(button => {
                    button.disabled = locked;
                });
                // Re-enable startTimerBtn for other tasks if a timer is globally active but not for this task specifically
                if (!locked) { // When unlocking a task (timer stopped)
                    // Enable all start timer buttons for active tasks
                    tasksContainer.querySelectorAll('tr .startTimerBtn').forEach((btn, idx) => {
                        const taskRow = btn.closest('tr');
                        const id = parseInt(taskRow.dataset.taskId);
                        const taskData = tasks.find(t => t.id === id);
                        if (taskData && taskData.isActive) {
                            btn.disabled = false; // Enable if task is active
                        }
                    });
                } else { // When locking a task (timer started for it)
                    // Disable all other startTimerBtns
                    tasksContainer.querySelectorAll('tr .startTimerBtn').forEach(btn => {
                        btn.disabled = true;
                    });
                }
            }
        }


        function startChrono(taskId) {
            if (activeTimerInterval) {
                const tempMsg = document.createElement('div');
                tempMsg.textContent = "Another timer is already active. Please stop it first.";
                tempMsg.className = "fixed top-5 right-5 bg-red-500 text-white p-3 rounded-md shadow-lg z-[2000]";
                document.body.appendChild(tempMsg);
                setTimeout(() => tempMsg.remove(), 3000);
                return;
            }

            currentTimerTaskIndex = tasks.findIndex(t => t.id === taskId);
            if (currentTimerTaskIndex === -1 || !tasks[currentTimerTaskIndex].isActive) return;

            const task = tasks[currentTimerTaskIndex];
            task.timerActualStartTimeValue = task.startTime;
            task.timerStartTimeActual = new Date();
            elapsedSeconds = 0;

            activeTimerProgramNameEl.textContent = task.programName;
            activeTimerScheduledDurationEl.textContent = formatDuration(task.duration);
            updateActiveTimerDisplay();
            activeTimerDisplay.style.display = 'block';

            setTaskInputsLocked(task.id, true); // Lock inputs for the current task
            renderTasks(); // Re-render to reflect disabled states on all buttons

            activeTimerInterval = setInterval(() => {
                elapsedSeconds++;
                updateActiveTimerDisplay();

                const scheduledDurationSeconds = task.duration * 60;
                if (elapsedSeconds > 0 && elapsedSeconds === scheduledDurationSeconds) { // Ensure it triggers only once when time is up
                    showWarningModal(task.programName);
                }
            }, 1000);
        }

        function stopChrono(isDeactivation = false) {
            if (!activeTimerInterval) return;

            clearInterval(activeTimerInterval);
            activeTimerInterval = null; // Crucial: set to null before further operations

            const taskBeingStopped = tasks[currentTimerTaskIndex];

            if (taskBeingStopped) {
                setTaskInputsLocked(taskBeingStopped.id, false); // Unlock inputs for this task

                if (!isDeactivation) {
                    const actualDurationMinutes = Math.ceil(elapsedSeconds / 60);
                    taskBeingStopped.duration = actualDurationMinutes;
                }
                // Reset timer-specific properties on the task object if they exist
                taskBeingStopped.elapsedSeconds = 0;
                taskBeingStopped.timerStartTimeActual = null;
                taskBeingStopped.timerActualStartTimeValue = null;
            }

            activeTimerDisplay.style.display = 'none';

            const originalTimerTaskIndex = currentTimerTaskIndex; // Store before resetting
            currentTimerTaskIndex = -1;
            elapsedSeconds = 0;

            if (!isDeactivation && taskBeingStopped) { // taskBeingStopped ensures index was valid
                recalculateChain(originalTimerTaskIndex); // Recalculate chain if stopped manually and duration changed
            } else {
                renderTasks(); // Generic re-render to update UI (e.g. button states)
            }
        }

        function updateActiveTimerDisplay() {
            if (currentTimerTaskIndex === -1 || !tasks[currentTimerTaskIndex]) return;
            const task = tasks[currentTimerTaskIndex];
            const scheduledDurationSeconds = task.duration * 60;
            const remainingSeconds = Math.max(0, scheduledDurationSeconds - elapsedSeconds);

            activeTimerCountdownEl.textContent = formatSecondsToHHMMSS(remainingSeconds);
            activeTimerElapsedTimeEl.textContent = formatSecondsToHHMMSS(elapsedSeconds);
        }

        function showWarningModal(programName) {
            warningProgramNameEl.textContent = programName;
            warningModal.style.display = 'flex';
        }
        function hideWarningModal() { warningModal.style.display = 'none'; }

        // --- Program Template Loading ---
        function loadProgramTemplate() {
            const selectedTemplateKey = programTemplateSelect.value;
            const template = programTemplates[selectedTemplateKey];
            if (!template) return;

            globalStartTime = template.globalStartTime;
            globalEndTime = template.globalEndTime;
            globalStartTimeInput.value = globalStartTime;
            globalEndTimeInput.value = globalEndTime;

            tasks = [];
            nextTaskId = 1;
            let currentStartTimeMinutes = timeToMinutes(globalStartTime);

            template.tasks.forEach(templateTask => {
                const newTask = {
                    id: nextTaskId++,
                    programName: templateTask.programName,
                    startTime: minutesToTime(currentStartTimeMinutes),
                    duration: templateTask.duration,
                    endTime: minutesToTime(currentStartTimeMinutes + templateTask.duration),
                    remarks: templateTask.remarks || '',
                    isActive: true,
                    // Removed timerIntervalId, elapsedSeconds from individual task template
                    timerStartTimeActual: null,
                    timerActualStartTimeValue: null
                };
                tasks.push(newTask);
                currentStartTimeMinutes += templateTask.duration;
            });

            if (selectedTemplateKey === 'custom' && tasks.length === 0) {
                addTask();
            } else {
                recalculateChain();
            }
        }

        // --- Data Handling ---
        function exportToJSON() {
            const data = { globalStartTime, globalEndTime, tasks, nextTaskId };
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `time_intervals_${getCurrentDateString()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function handleImportJSON(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    globalStartTime = data.globalStartTime || "09:00";
                    globalEndTime = data.globalEndTime || "17:00";
                    tasks = data.tasks || [];
                    nextTaskId = data.nextTaskId || (tasks.length > 0 ? Math.max(...tasks.map(t => t.id)) + 1 : 1);

                    tasks.forEach(task => {
                        task.isActive = typeof task.isActive === 'boolean' ? task.isActive : true;
                        task.duration = task.duration || calculateDuration(task.startTime, task.endTime);
                        // Ensure no stale timer properties from JSON
                        task.timerStartTimeActual = null;
                        task.timerActualStartTimeValue = null;
                    });

                    globalStartTimeInput.value = globalStartTime;
                    globalEndTimeInput.value = globalEndTime;
                    programTemplateSelect.value = "custom";
                    recalculateChain();
                } catch (error) {
                    console.error("Error parsing JSON:", error);
                    // ... (error message display)
                }
            };
            reader.readAsText(file);
            importJsonInput.value = '';
        }

        function exportToExcel() {
            const dataToExport = tasks.map(task => ({
                Status: task.isActive ? 'Active' : 'Inactive',
                'Program Name': task.programName, 'Start Time': task.startTime,
                'End Time': task.endTime, 'Duration (min)': task.duration, Remarks: task.remarks
            }));
            const worksheet = XLSX.utils.json_to_sheet(dataToExport);
            XLSX.utils.sheet_add_aoa(worksheet, [
                ["Global Start Time:", globalStartTime], ["Global End Time:", globalEndTime], []
            ], { origin: "A" + (dataToExport.length + 3) });
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, "Program Tasks");
            XLSX.writeFile(workbook, `time_intervals_${getCurrentDateString()}.xlsx`);
        }

        // --- Local Storage ---
        function saveState() {
            const state = {
                selectedTemplate: programTemplateSelect.value, globalStartTime, globalEndTime, tasks, nextTaskId
            };
            localStorage.setItem('timeIntervalManagerState', JSON.stringify(state));
        }

        function loadState() {
            const savedState = localStorage.getItem('timeIntervalManagerState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    programTemplateSelect.value = state.selectedTemplate || "custom";
                    if (state.selectedTemplate && state.selectedTemplate !== "custom" && (!state.tasks || state.tasks.length === 0 || !state.tasks.some(t => t.programName))) { // check if tasks are actually loaded
                        loadProgramTemplate();
                    } else {
                        globalStartTime = state.globalStartTime || "09:00";
                        globalEndTime = state.globalEndTime || "17:00";
                        tasks = state.tasks || [];
                        nextTaskId = state.nextTaskId || (tasks.length > 0 ? Math.max(...tasks.map(t => t.id)) + 1 : 1);
                        tasks.forEach(task => {
                            task.isActive = typeof task.isActive === 'boolean' ? task.isActive : true;
                            task.duration = task.duration || calculateDuration(task.startTime, task.endTime);
                            task.timerStartTimeActual = null; // Reset timer states on load
                            task.timerActualStartTimeValue = null;
                        });
                        globalStartTimeInput.value = globalStartTime;
                        globalEndTimeInput.value = globalEndTime;
                        recalculateChain();
                    }
                } catch (e) {
                    console.error("Error loading state from localStorage:", e);
                    programTemplateSelect.value = "custom"; loadProgramTemplate();
                }
            } else {
                programTemplateSelect.value = "custom"; loadProgramTemplate();
            }
        }

        // --- Drag and Drop ---
        tasksContainer.addEventListener('dragstart', (e) => { /* ... existing ... */ });
        tasksContainer.addEventListener('dragend', (e) => { /* ... existing ... */ });
        tasksContainer.addEventListener('dragover', (e) => { /* ... existing ... */ });
        tasksContainer.addEventListener('dragleave', (e) => { /* ... existing ... */ });
        tasksContainer.addEventListener('drop', (e) => { /* ... existing ... (ensure recalculateChain is called) */ });

        // --- Event Listeners Setup ---
        programTemplateSelect.addEventListener('change', loadProgramTemplate);
        globalStartTimeInput.addEventListener('change', updateGlobalTimes);
        globalEndTimeInput.addEventListener('change', updateGlobalTimes);
        addRowBtn.addEventListener('click', addTask);

        exportJsonBtn.addEventListener('click', exportToJSON);
        importJsonBtn.addEventListener('click', () => importJsonInput.click());
        importJsonInput.addEventListener('change', handleImportJSON);
        exportExcelBtn.addEventListener('click', exportToExcel);

        activeTimerStopBtn.addEventListener('click', () => stopChrono(false));


        tasksContainer.addEventListener('change', (e) => { // For time, duration (on blur/enter)
            const target = e.target;
            const row = target.closest('tr');
            if (!row || !row.dataset.taskId) return;
            const taskId = parseInt(row.dataset.taskId, 10);
            const task = tasks.find(t => t.id === taskId);
            if (task && task.isActive && !(activeTimerInterval && tasks[currentTimerTaskIndex].id === taskId)) { // Check if not locked
                if (target.classList.contains('startTimeInput')) {
                    updateTaskData(taskId, 'startTime', target.value);
                } else if (target.classList.contains('endTimeInput')) {
                    updateTaskData(taskId, 'endTime', target.value);
                } else if (target.classList.contains('durationInput')) {
                    updateTaskData(taskId, 'duration', parseInt(target.value, 10));
                }
            }
        });

        tasksContainer.addEventListener('input', (e) => { // For program name, remarks (live typing)
            const target = e.target;
            const row = target.closest('tr');
            if (!row || !row.dataset.taskId) return;
            const taskId = parseInt(row.dataset.taskId, 10);
            const task = tasks.find(t => t.id === taskId);

            if (task && task.isActive && !(activeTimerInterval && tasks[currentTimerTaskIndex] && tasks[currentTimerTaskIndex].id === taskId)) { // Check if not locked
                if (target.classList.contains('programNameInput')) {
                    updateTaskData(taskId, 'programName', target.value);
                } else if (target.classList.contains('remarksInput')) {
                    updateTaskData(taskId, 'remarks', target.value);
                }
            }
        });

        tasksContainer.addEventListener('click', (e) => {
            const targetButton = e.target.closest('button');
            if (!targetButton) return;

            const row = targetButton.closest('tr');
            if (!row || !row.dataset.taskId) return; // Ensure click is on a button within a task row

            const taskId = parseInt(row.dataset.taskId, 10);

            if (targetButton.classList.contains('removeRowBtn')) {
                if (window.confirm('Are you sure you want to remove this task?')) {
                    removeTask(taskId);
                }
            } else if (targetButton.classList.contains('toggleStatusBtn')) {
                toggleTaskStatus(taskId);
            } else if (targetButton.classList.contains('startTimerBtn')) {
                startChrono(taskId);
            }
        });

        closeWarningModalBtn.addEventListener('click', hideWarningModal);

        window.onclick = function (event) {
            // if (event.target == timerModal) { /* Removed */ }
            if (event.target == warningModal) { hideWarningModal(); }
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            loadState();
        });

    </script>
</body>

</html>